// Earth Engine script "AlpineZone_NDVI" v4 (2025-07-20)
// Jonathan W. Chipman, Department of Geography
// Dartmouth College, Hanover NH USA
// 
// With contributions from (in chronological order)
//   Jenny Vazquez Torres, Irene Ko, Onome Ofoman

// Mann-Kendall trend analysis from N. Clinton, here:
// https://developers.google.com/earth-engine/tutorials/community/nonparametric-trends
//
// Revised to handle inter-satellite calibration and other improvements
// Revised to allow site-specific code to be edited at the top
//
// This code processes Landsat TM, ETM+, and OLI imagery for analysis of
//   NDVI trends and phenology in alpine zones (AZ) and the adjacent 
//   upper subalpine zone (USAZ) of northeastern North America.


print(AZ_all);

// *** EDIT THIS PARAMETER FOR EACH SITE
var siteName = "QC_MSA";
var siteFolder = siteName + "_GEE_v4";
// Before running this, be sure the above folder exists somewhere on your drive
// E.g., "QC_JAC_GEE_Export_v4"

// *** EDIT THESE TO CHOOSE OUTPUTS
var make_CSV_files = true;
var make_raster_files = true;

// *** EDIT THESE PARAMETERS AS NEEDED
var siteScale = 30;                     // Scale in meters for output GeoTIFFs
var cloud_score = 25;                   // Max acceptable image-wide cloud threshold
var start_month = 6;                    // Starting month for useable images (June)
var end_month = 9;                      // Ending month for useable images (September)
var startDateEarly = "1984-01-01";      // Start of first decade, for averaging
var endDateEarly = "1993-12-31";        // End of first decade, for averaging
var startDateLate = "2015-01-01";       // Start of last decade, for averaging
var endDateLate = "2024-12-31";         // End of last decade, for averaging
var startYear = 1984;                   // Start year for Mann-Kendall trend
var endYear = 2024;                     // End year for Mann-Kendall trend
var doAdjustNDVI = true;               // Adjust NDVI for older satellites?



// Assume the first two characters are the state or province abbreviation
var stateProvince = siteName.substring(0,2);

// Construct variables based on this
var azName = siteName + "_AZ";
var usazName = siteName + "_USAZ";
var timeSeriesAZ_all = "NDVI_timeseries_AZ_all";
var timeSeriesAZ_pc50 = "NDVI_timeseries_AZ_pc50";
var timeSeriesUSAZ_all = "NDVI_timeseries_USAZ_all";
var timeSeriesUSAZ_pc50 = "NDVI_timeseries_USAZ_pc50";
var nameKendallGeoTIFF = "kendall";
var nameSignificantGeoTIFF = "kendall_significant";
var namePvalGeoTIFF = "kendall_pval";
var nameChangeGeoTIFF = "NDVI_change";
var nameMeanGeoTIFF = "mean_allbands";
var nameEarlyGeoTIFF = "NDVI_early";
var nameLateGeoTIFF = "NDVI_late";
var nameNdviGeoTIFF = "NDVI_mean";
var namePositiveGeoTIFF = "kendall_positive";
var nameNegativeGeoTIFF = "kendall_negative";
var nameValidCountGeoTIFF = "valid_count";
var nameSnowCountGeoTIFF = "snow_count";
var nameCloudCountGeoTIFF = "cloud_count";

// Determine the appropriate UTM zone and CRS
var siteCRS;
switch(stateProvince) {
  case "NY": siteCRS = 'EPSG:32618';
    break;
  case "VT": siteCRS = 'EPSG:32618';
    break;
  case "NH": siteCRS = 'EPSG:32619';
    break;
  case "ME": siteCRS = 'EPSG:32619';
    break;
  case "QC": siteCRS = 'EPSG:32619';
    break;
  case "NL": siteCRS = 'EPSG:32621';
    break;
  default: siteCRS = 'EPSG:32619';
} 

// AZ - alpine zone - select from table
var alpineZone = ee.FeatureCollection(AZ_all)
  .filter(ee.Filter.eq("SiteZone", azName))
  .geometry();
  
// USAZ - upper sub alpine zone - select from table
var usaz = ee.FeatureCollection(USAZ_all)
  .filter(ee.Filter.eq("SiteZone", usazName))
  .geometry();
  
var alpineZoneBounds = alpineZone.bounds(); // rectangle
var usazBounds = usaz.bounds(); // rectangle

// Combine study_area boundaries (rectangle) and buffer by 500m
var study_area = alpineZoneBounds.union(usazBounds, 1).buffer(500).bounds(); 

// Add boundaries to map
Map.addLayer(study_area, null, 'StudyArea');
Map.addLayer(alpineZone, null, 'AlpineZone');
Map.addLayer(usaz, null, 'USAZ');

// Brings map to center
Map.centerObject(study_area, 11);



// Filter Landsat data
// (see definitions at top of code for start and end months, and cloud score)
var allImages5 = ee.ImageCollection(Landsat5_SR
  .filterMetadata("CLOUD_COVER", "less_than", cloud_score)
  .filter(ee.Filter.calendarRange(start_month, end_month, 'month'))
  .filter(ee.Filter.calendarRange(startYear, endYear, 'year'))
  .filterBounds(study_area) 
  );
var allImages7 = ee.ImageCollection(Landsat7_SR
  .filterMetadata("CLOUD_COVER", "less_than", cloud_score)
  .filter(ee.Filter.calendarRange(start_month, end_month, 'month'))  
  .filter(ee.Filter.calendarRange(startYear, endYear, 'year'))
  .filterBounds(study_area));
var allImages8 = ee.ImageCollection(Landsat8_SR
  .filterMetadata("CLOUD_COVER", "less_than", cloud_score)
  .filter(ee.Filter.calendarRange(start_month, end_month, 'month'))  
  .filter(ee.Filter.calendarRange(startYear, endYear, 'year'))
  .filterBounds(study_area));
var allImages9 = ee.ImageCollection(Landsat9_SR
  .filterMetadata("CLOUD_COVER", "less_than", cloud_score)
  .filter(ee.Filter.calendarRange(start_month, end_month, 'month'))  
  .filter(ee.Filter.calendarRange(startYear, endYear, 'year'))
  .filterBounds(study_area));
  
// Count the number of images by each satellite
var count5 = allImages5.size();
print("Landsat-5 images: ", count5);
var count7 = allImages7.size();
print("Landsat-7 images: ", count7);
var count8 = allImages8.size();
print("Landsat-8 images: ", count8);
var count9 = allImages9.size();
print("Landsat-9 images: ", count9);


// Rename Landsat bands (5 and 7, vs 8 and 9)
var rename5_7 = function(myImage) {
  var img = myImage.select(['SR_B1','SR_B2','SR_B3','SR_B4','SR_B5','SR_B7','QA_PIXEL','QA_RADSAT'])
    .rename(['B','G','R','NIR','SWIR1','SWIR2','QA_PIXEL','QA_RADSAT']);
  return img;
};
// Rename Landsat 8 and Landsat 9 bands
var rename8_9 = function(myImage) {
  var img = myImage.select(['SR_B2','SR_B3','SR_B4','SR_B5','SR_B6','SR_B7','QA_PIXEL','QA_RADSAT'])
    .rename(['B','G','R','NIR','SWIR1','SWIR2','QA_PIXEL','QA_RADSAT']);
  return img;
};
var renamed5 = allImages5.map(rename5_7);
var renamed7 = allImages7.map(rename5_7);
var renamed8 = allImages8.map(rename8_9);
var renamed9 = allImages9.map(rename8_9);


// Calculate NDVI, and adjust it for inter-satellite calibration differences if requested
// These differences were empirically calculated based on comparison of pairs of
//    images from 12 alpine zone sites, taken 1 day apart, by different satellites.

// Add a new band for NDVI (unadjusted)
var addNDVI = function(myImage) {
  var NDVI = myImage.normalizedDifference(["NIR","R"]).double();
  return myImage
  .addBands(NDVI.rename('NDVI'));
};

if (doAdjustNDVI) {
  // Add a new band for NDVI (adjusted) on L5
  var addNDVI2_L5 = function(myImage) {
    var NDVI2 = myImage.expression(
      '0.976238332314974 * NDVI + 0.0262850594231641', {
        'NDVI': myImage.select('NDVI').double()
    });
    return myImage
    .addBands(NDVI2.rename('NDVI2'));
  };
  
  // Add a new band for NDVI (adjusted) on L7
  var addNDVI2_L7 = function(myImage) {
    var NDVI2 = myImage.expression(
      '0.970326287711007 * NDVI + 0.0197365816580834', {
        'NDVI': myImage.select('NDVI').double()
    });
    return myImage
    .addBands(NDVI2.rename('NDVI2'));
  };
  
  // Add a new band for NDVI (adjusted) on L8
  var addNDVI2_L8 = function(myImage) {
    var NDVI2 = myImage.expression(
      '1.01336159433426 * NDVI + 0.0023880504434606', {
        'NDVI': myImage.select('NDVI').double()
    });
    return myImage
    .addBands(NDVI2.rename('NDVI2'));
  };

  // Add a new band for NDVI (no adjustment needed) on L9
  var addNDVI2_L9 = function(myImage) {
    var NDVI2 = myImage.select('NDVI').double();
    return myImage
    .addBands(NDVI2.rename('NDVI2'));
  };
} // End of optional calculation of adjusted NDVI



// Calculate NDSI, and adjust it for inter-satellite calibration differences
// These differences were empirically calculated based on comparison of pairs of
//    images from 12 alpine zone sites, taken 1 day apart, by different satellites.

//Add a new band for NDSI (unadjusted)
var addNDSI = function(myImage) {
  var NDSI = myImage.normalizedDifference(["G","SWIR1"]).double();
  return myImage
  .addBands(NDSI.rename('NDSI'));
};

//Add a new band for NDSI2 (adjusted) on L5
var addNDSI2_L5 = function(myImage) {
  var NDSI2 = myImage.expression(
    '1.18184922361351 * NDSI + 0.0343116464413973', {
      'NDSI': myImage.select('NDSI').double()
  });
  return myImage
  .addBands(NDSI2.rename('NDSI2'));
};

//Add a new band for NDSI2 (adjusted) on L7
var addNDSI2_L7 = function(myImage) {
  var NDSI2 = myImage.expression(
    '1.18298794458194 * NDSI + 0.0386808931915994', {
      'NDSI': myImage.select('NDSI').double()
  });
  return myImage
  .addBands(NDSI2.rename('NDSI2'));
};

//Add a new band for NDSI2 (adjusted) on L8
var addNDSI2_L8 = function(myImage) {
  var NDSI2 = myImage.expression(
    '1.01336159433426 * NDSI + 0.0023880504434606', {
      'NDSI': myImage.select('NDSI').double()
  });
  return myImage
  .addBands(NDSI2.rename('NDSI2'));
};

//Add a new band for NDSI2 (no adjustment needed) on L9
var addNDSI2_L9 = function(myImage) {
  var NDSI2 = myImage.select('NDSI').double();
  return myImage
  .addBands(NDSI2.rename('NDSI2'));
};




// Apply various masks to remove non-usable image pixels

// Mask images to remove clouds and saturated detector artifacts
// For conservatism, apply a 2-pixel-wide buffer around masked areas
var doMask_Cloud = function(myImage) {
  // Bit 0 = Fill
  // Bit 1 = Dilated Cloud
  // Bit 2 = Cirrus (Landsat-8 only)
  // Bit 3 = Cloud
  // Bit 4 = Cloud Shadow
  var qaMask = myImage
    .clip(study_area).select('QA_PIXEL')
    .bitwiseAnd(parseInt('11111',2)).neq(0);
  var saturationMask = myImage
    .clip(study_area).select('QA_RADSAT').neq(0);
  var badPix = qaMask.or(saturationMask);
  var badPixBuffer = badPix.focal_max({
    radius: 60,
    kernelType: 'circle',
    units:'meters',
    iterations: 1
  });
  var comboMask = badPixBuffer.eq(0); // get everything that is NOT bad
  var imgMasked = myImage.updateMask(comboMask);
  return imgMasked;
};


// Mask images to remove water bodies
// For conservatism, apply a 2-pixel-wide buffer around masked areas
var doMask_Water = function (myImage) {
  var water = JRC_Water.select('max_extent').clip(study_area).eq(1);
  var waterBuffer = water.focal_max({
    radius: 60,
    kernelType: 'circle',
    units:'meters',
    iterations: 1
  });
  var waterMask = waterBuffer.eq(0); // get everything that is NOT water
  var imgMasked = myImage.updateMask(waterMask);
  return imgMasked;
};
  
  
// Mask images to remove snow
// Note this uses the adjusted NDSI; assumes values > 0 are problematic
var doMask_Snow = function(myImage) {
  var NDSI2 = myImage.select('NDSI2');
  var snowMask = NDSI2.lt(0.0);
  var imgMasked = myImage.updateMask(snowMask);
  return imgMasked;
};


//Add a new band for PixelCount
// This gets done at the end of the following sequence, after all masks
var addPixelCount = function(myImage) {
  var n = myImage.select('NDVI');
  var pc = n.gt(-99);
  return myImage
  .addBands(pc.rename('PixelCount'));
};


if (doAdjustNDVI) {
  // Actually do the index calculations and apply the masks
  var clearImages5 = renamed5.map(addNDVI).map(addNDSI).map(addNDSI2_L5).map(addNDVI2_L5)
    .map(doMask_Cloud).map(doMask_Water).map(doMask_Snow).map(addPixelCount);
  var clearImages7 = renamed7.map(addNDVI).map(addNDSI).map(addNDSI2_L7).map(addNDVI2_L7)
    .map(doMask_Cloud).map(doMask_Water).map(doMask_Snow).map(addPixelCount);
  var clearImages8 = renamed8.map(addNDVI).map(addNDSI).map(addNDSI2_L8).map(addNDVI2_L8)
    .map(doMask_Cloud).map(doMask_Water).map(doMask_Snow).map(addPixelCount);
  var clearImages9 = renamed9.map(addNDVI).map(addNDSI).map(addNDSI2_L9).map(addNDVI2_L9)
    .map(doMask_Cloud).map(doMask_Water).map(doMask_Snow).map(addPixelCount);
  
  // Merge the images from all satellites
  var clearImgs1 = clearImages5.merge(clearImages7).merge(clearImages8).merge(clearImages9);
  
  // Rename recalibrated NDVI and NDSI bands (and drop the original versions)
  var renameNDVI_NDSI = function(myImage) {
    var img = myImage.select(['B','G','R','NIR','SWIR1','SWIR2','QA_PIXEL','QA_RADSAT','NDSI2','NDVI2', 'PixelCount'])
      .rename(['B','G','R','NIR','SWIR1','SWIR2','QA_PIXEL','QA_RADSAT','NDSI','NDVI', 'PixelCount']);
    return img;
  };
  var clearImages = clearImgs1.map(renameNDVI_NDSI);
} // End of section for optional NDVI adjustment = true

else {
  // Actually do the index calculations and apply the masks
  var clearImages5 = renamed5.map(addNDVI).map(addNDSI).map(addNDSI2_L5)
    .map(doMask_Cloud).map(doMask_Water).map(doMask_Snow).map(addPixelCount);
  var clearImages7 = renamed7.map(addNDVI).map(addNDSI).map(addNDSI2_L7)
    .map(doMask_Cloud).map(doMask_Water).map(doMask_Snow).map(addPixelCount);
  var clearImages8 = renamed8.map(addNDVI).map(addNDSI).map(addNDSI2_L8)
    .map(doMask_Cloud).map(doMask_Water).map(doMask_Snow).map(addPixelCount);
  var clearImages9 = renamed9.map(addNDVI).map(addNDSI).map(addNDSI2_L9)
    .map(doMask_Cloud).map(doMask_Water).map(doMask_Snow).map(addPixelCount);
  
  // Merge the images from all satellites
  var clearImgs1 = clearImages5.merge(clearImages7).merge(clearImages8).merge(clearImages9);
  
  // Rename recalibrated NDVI and NDSI bands (and drop the original versions)
  var rename_NDSI = function(myImage) {
    var img = myImage.select(['B','G','R','NIR','SWIR1','SWIR2','QA_PIXEL','QA_RADSAT','NDSI2', 'NDVI', 'PixelCount'])
      .rename(['B','G','R','NIR','SWIR1','SWIR2','QA_PIXEL','QA_RADSAT','NDSI', 'NDVI', 'PixelCount']);
    return img;
  };
  var clearImages = clearImgs1.map(rename_NDSI);
} // End of section for optional NDVI adjustment = false


// Only do CSV files if user set this variable at the top
if (make_CSV_files === true) {

  // Compute time series for AZ and USAZ, and export them as CSV files
  // As part of this process, calculate the % of valid pixels on each date
  
  // Calculate time series of mean NDVI for entire Alpine Zone
  var doReduceRegion = function(myImage) {
    var mean = myImage.reduceRegion({
      geometry:alpineZone, 
      reducer:ee.Reducer.mean(), 
      scale:siteScale
    });
    
    var date = myImage.date().format();
    var meanNDVI = mean.get('NDVI');
    var satellite = myImage.get('SPACECRAFT_ID');
    var path = myImage.get('WRS_PATH');
    var row = myImage.get('WRS_ROW');
    var date2 = myImage.get('DATE_ACQUIRED');    
    return ee.Feature(null)
    .set('date',date)
    .set('meanNDVI',meanNDVI)
    .set('satellite',satellite)
    .set('path',path)
    .set('row',row)
    .set('date2',date2);
  }; // End of function doReduceRegion
  
  // Map the function and delete any rows with nulls from the output
  var statsAZ_ndvi = ee.FeatureCollection(clearImages.select('NDVI').map(doReduceRegion));
  var filteredAZ_ndvi = statsAZ_ndvi.filter(ee.Filter.neq('meanNDVI', null));
  
  // Calculate time series of valid pixel counts for entire Alpine Zone
  var doReduceRegion_PC = function(myImage) {
    var sum = myImage.reduceRegion({
      geometry:alpineZone, 
      reducer:ee.Reducer.sum(), 
      scale:siteScale
    });
    
    var date = myImage.date().format();
    var sumPixelCount = sum.get('PixelCount');
    var satellite = myImage.get('SPACECRAFT_ID');
    var path = myImage.get('WRS_PATH');
    var row = myImage.get('WRS_ROW');
    var date2 = myImage.get('DATE_ACQUIRED');    
    return ee.Feature(null)
    .set('date',date)
    .set('sumPixelCount',sumPixelCount)
    .set('satellite',satellite)
    .set('path',path)
    .set('row',row)
    .set('date2',date2);
  }; // End of function doReduceRegion_PC
  
  // Map the function and delete any rows with nulls or zeros from the output
  var statsAZ_pc = ee.FeatureCollection(clearImages.select('PixelCount').map(doReduceRegion_PC));
  var filtered1 = statsAZ_pc.filter(ee.Filter.neq('sumPixelCount', null));
  var filteredAZ_pc = filtered1.filter(ee.Filter.neq('sumPixelCount', 0));
  
  // Join the tables for mean NDVI and valid pixel count
  var innerJoin = ee.Join.inner();
  
  // Specify an equals filter for image timestamps.
  var filterTimeEq = ee.Filter.equals({
    leftField: 'date',
    rightField: 'date'
  });
  
  // Join the NDVI and pixel count tables for AZ
  var innerJoinedAZ = innerJoin.apply(filteredAZ_ndvi, filteredAZ_pc, filterTimeEq);
  
  // Calculate percent coverage of valid pixels for AZ
  var statsAZ_pc_max = statsAZ_pc.aggregate_max('sumPixelCount');
  var calcPctValid = function(feature) {
    var pc = feature.getNumber('secondary.sumPixelCount');
    var pctValid = pc.divide(statsAZ_pc_max);
    return feature.set('pctValid',pctValid);
  };
  var filteredAZ_all = innerJoinedAZ.map(calcPctValid);
  
  // Select only records with at least 50% valid pixels
  var filteredAZ_pc50 = filteredAZ_all.filter(ee.Filter.gte('pctValid', 0.5));
  
  Export.table.toDrive({
    collection: ee.FeatureCollection(filteredAZ_all),
    folder: siteFolder,
    fileNamePrefix: timeSeriesAZ_all,
    fileFormat: 'csv',
    selectors: ['primary.date', 'primary.date2', 'primary.satellite', 'primary.path', 'primary.row', 'primary.meanNDVI', 'pctValid'],
  });
  
  Export.table.toDrive({
    collection: ee.FeatureCollection(filteredAZ_pc50),
    folder: siteFolder,
    fileNamePrefix: timeSeriesAZ_pc50,
    fileFormat: 'csv',
    selectors: ['primary.date', 'primary.date2', 'primary.satellite', 'primary.path', 'primary.row', 'primary.meanNDVI', 'pctValid'],
  });
  
  
  // Calculate time series of mean NDVI for entire Upper SubAlpine Zone
  var doReduceRegion = function(myImage) {
    var mean = myImage.reduceRegion({
      geometry:usaz, 
      reducer:ee.Reducer.mean(), 
      scale:siteScale
    });
    
    var date = myImage.date().format();
    var meanNDVI = mean.get('NDVI');
    var satellite = myImage.get('SPACECRAFT_ID');
    var path = myImage.get('WRS_PATH');
    var row = myImage.get('WRS_ROW');
    var date2 = myImage.get('DATE_ACQUIRED');    
    return ee.Feature(null)
    .set('date',date)
    .set('meanNDVI',meanNDVI)
    .set('satellite',satellite)
    .set('path',path)
    .set('row',row)
    .set('date2',date2);
  }; // End of function doReduceRegion
  
  // Map the function and delete any rows with nulls from the output
  var statsUSAZ_ndvi = ee.FeatureCollection(clearImages.select('NDVI').map(doReduceRegion));
  var filteredUSAZ_ndvi = statsUSAZ_ndvi.filter(ee.Filter.neq('meanNDVI', null));
  
  
  // Calculate time series of valid pixel counts for entire Alpine Zone
  var doReduceRegion_USAZ_PC = function(myImage) {
    var sum = myImage.reduceRegion({
      geometry:usaz, 
      reducer:ee.Reducer.sum(), 
      scale:siteScale
    });
    
    var date = myImage.date().format();
    var sumPixelCount = sum.get('PixelCount');
    var satellite = myImage.get('SPACECRAFT_ID');
    var path = myImage.get('WRS_PATH');
    var row = myImage.get('WRS_ROW');
    var date2 = myImage.get('DATE_ACQUIRED');    
    return ee.Feature(null)
    .set('date',date)
    .set('sumPixelCount',sumPixelCount)
    .set('satellite',satellite)
    .set('path',path)
    .set('row',row)
    .set('date2',date2);
  }; // End of function doReduceRegion_PC
  
  // Map the function and delete any rows with nulls or zeros from the output
  var statsUSAZ_pc = ee.FeatureCollection(clearImages.select('PixelCount').map(doReduceRegion_USAZ_PC));
  var filtered1 = statsUSAZ_pc.filter(ee.Filter.neq('sumPixelCount', null));
  var filteredUSAZ_pc = filtered1.filter(ee.Filter.neq('sumPixelCount', 0));
  
  
  // Join the NDVI and pixel count tables for USAZ
  var innerJoinedUSAZ = innerJoin.apply(filteredUSAZ_ndvi, filteredUSAZ_pc, filterTimeEq);
  
  // Calculate percent coverage of valid pixels for USAZ
  var statsUSAZ_pc_max = statsUSAZ_pc.aggregate_max('sumPixelCount');
  var calcPctValid_USAZ = function(feature) {
    var pc = feature.getNumber('secondary.sumPixelCount');
    var pctValid = pc.divide(statsUSAZ_pc_max);
    return feature.set('pctValid',pctValid);
  };
  var filteredUSAZ_all = innerJoinedUSAZ.map(calcPctValid_USAZ);
  
  // Select only records with at least 50% valid pixels
  var filteredUSAZ_pc50 = filteredUSAZ_all.filter(ee.Filter.gte('pctValid', 0.5));
  
  Export.table.toDrive({
    collection: ee.FeatureCollection(filteredUSAZ_all),
    folder: siteFolder,
    fileNamePrefix: timeSeriesUSAZ_all,
    fileFormat: 'csv',
    selectors: ['primary.date', 'primary.date2', 'primary.satellite', 'primary.path', 'primary.row', 'primary.meanNDVI', 'pctValid'],
  });
  
  Export.table.toDrive({
    collection: ee.FeatureCollection(filteredUSAZ_pc50),
    folder: siteFolder,
    fileNamePrefix: timeSeriesUSAZ_pc50,
    fileFormat: 'csv',
    selectors: ['primary.date', 'primary.date2', 'primary.satellite', 'primary.path', 'primary.row', 'primary.meanNDVI', 'pctValid'],
  });

} // End of exporting CSV files (if make_CSV_files == true)




// Definitions of the cumulative distribution function
// https://en.wikipedia.org/wiki/Error_function#Cumulative_distribution_function
// For use in Mann-Kendall below
function eeCdf(z) {
  return ee.Image(0.5)
    .multiply(ee.Image(1).add(ee.Image(z).divide(ee.Image(2).sqrt()).erf()));
}
function invCdf(p) {
  return ee.Image(2).sqrt()
    .multiply(ee.Image(p).multiply(2).subtract(1).erfInv());
}
  


// Only do raster files if user set this variable at the top
if (make_raster_files === true) {
  
  // Calculate various images for export
  
  // First, an image with the overall mean across entire time period, for all bands
  var overallMeanImage = clearImages.mean();
  Map.addLayer(overallMeanImage.select("NDVI"), visNDVI, 'NDVI');
  
  // Calculate the mean NDVI from the first and last decades 
  // (see top of code for definitions):
  var earlyImages = clearImages
    .filterDate(startDateEarly, endDateEarly);
  var lateImages = clearImages
    .filterDate(startDateLate, endDateLate);
  var getEarlyNDVI = earlyImages.select("NDVI");
  var getLateNDVI = lateImages.select("NDVI");
  var earlyMean = getEarlyNDVI.reduce(ee.Reducer.mean());
  var lateMean = getLateNDVI.reduce(ee.Reducer.mean());
  
  // Calculate the change in NDVI between first and last decades
  var changeNDVI = lateMean.subtract(earlyMean);
  Map.addLayer(changeNDVI, null, 'Change in NDVI');
  
  // Calculate the # of valid image dates per pixel
  var getPixelCount = clearImages.select("PixelCount");
  var validCount = getPixelCount.reduce(ee.Reducer.sum());
  var validCountInt = validCount.toInt();
  
  
  // Make annual summer mean images from image collection, for each year
  // These will be used as input to the Mann-Kendall test
  // (we want 1 datum per year, not 1 per image date)
  
  
  // Iterator to loop over years
  var Year;
  
  // Within a given year, this is the starting and ending day (usually Jan 1 and Dec 31)
  // (however, note that above we started with only images during growing season months.)
  var yrStartDate;
  var yrEndDate;
  
  // For a given year, this is an image containing the mean value in each band
  var meanImage;
  
  // An image collection for all years, to be filled with individual years
  var annualImages;
  var annualImages_List = ee.List([]);
  
  // Loop over all years, to get the range for each year
  // (See top of code for definitions of starting and ending year.)
  for (Year=startYear; Year<=endYear;Year++) {
    yrStartDate = ee.Date.fromYMD(Year, 1, 1);
    yrEndDate = ee.Date.fromYMD(Year, 12, 31);
   
    // Select this year's images
    var selectedImages = clearImages.filterDate(yrStartDate, yrEndDate);
  
    var count = selectedImages.size().getInfo();
    print(String(Year) + ": " + count);
  
    // Test to make sure there is at least 1 image in this year
    if (count > 0) {
      var meanImage = selectedImages
      .mean()
      .clip(study_area);
      annualImages_List = annualImages_List.add(meanImage);
    }
      
  } // End of loop over years
  
  // Make an ImageCollection from the list of images (1 per year)
  annualImages = ee.ImageCollection.fromImages(annualImages_List);
  
  // Commented out, but can be used for testing:
  // Display image #31 (2014?) as an example
  // I recommend displaying this with bands SWIR1, NIR, R using a 98% stretch
  // or a 2-sigma stretch or something.
  // var myImg=ee.Image(annualImages_List.get(31));
  // Map.addLayer(myImg, null, "2014 image");
  
  
  
  
  // MANN-KENDALL NONPARAMETRIC TREND ANALYSIS
  // From here: 
  // https://developers.google.com/earth-engine/tutorials/community/nonparametric-trends
  
  
  // Need to have integer (non-floating-point) version of NDVI
  var addNDVI_Int = function(myImage) {
    var NDVI_Int = myImage.select('NDVI').multiply(10000).toInt();
    return myImage
    .addBands(NDVI_Int.rename('NDVI_Int'));
  };
  
  // Add the integer version of NDVI band onto each image in the collection
  var clearImages2 = annualImages.map(addNDVI_Int);
  var coll = clearImages2.select('NDVI_Int');
  
  
  // Start by joining the time-series to itself (each image linked to all later images)
  // Note: In the original, leftField and rightField below are "system:time_start"
  // But that property is not preserved when the images are aggregated by year
  var afterFilter = ee.Filter.lessThan({
    leftField: 'system:index',
    rightField: 'system:index'
  });
  
  var joined = ee.ImageCollection(ee.Join.saveAll('after').apply({
    primary: coll,
    secondary: coll,
    condition: afterFilter
  }));
  
  
  // Compute the Mann-Kendall trend statistic
  var sign = function(i, j) { // i and j are images
    return ee.Image(j).neq(i) // Zero case
        .multiply(ee.Image(j).subtract(i).clamp(-1, 1)).int();
  };
  
  var kendall = ee.ImageCollection(joined.map(function(current) {
    var afterCollection = ee.ImageCollection.fromImages(current.get('after'));
    return afterCollection.map(function(image) {
      // The unmask is to prevent accumulation of masked pixels that
      // result from the undefined case of when either current or image
      // is masked.  It won't affect the sum, since it's unmasked to zero.
      return ee.Image(sign(current, image)).unmask(0);
    });
    // Set parallelScale to avoid User memory limit exceeded.
  }).flatten()).reduce('sum', 2);
  
  // Set the layer symbology and display it on the map
  var palette = ['red', 'white', 'green'];
  var vizKendall = {
    bands: ['NDVI_Int_sum'],
    min: -50,
    max: 50,
    palette: palette
  };
  Map.addLayer(kendall, vizKendall, 'kendall');
  
  
  // Next, calculate the variance of the Mann-Kendall statistic
  // Values that are in a group (ties).  Set all else to zero.
  var groups = coll.map(function(i) {
    var matches = coll.map(function(j) {
      return i.eq(j); // i and j are images.
    }).sum();
    return i.multiply(matches.gt(1));
  });
  
  // Compute tie group sizes in a sequence.  The first group is discarded.
  var group = function(array) {
    var length = array.arrayLength(0);
    // Array of indices.  These are 1-indexed.
    var indices = ee.Image([1])
        .arrayRepeat(0, length)
        .arrayAccum(0, ee.Reducer.sum())
        .toArray(1);
    var sorted = array.arraySort();
    var left = sorted.arraySlice(0, 1);
    var right = sorted.arraySlice(0, 0, -1);
    // Indices of the end of runs.
    var mask = left.neq(right)
    // Always keep the last index, the end of the sequence.
        .arrayCat(ee.Image(ee.Array([[1]])), 0);
    var runIndices = indices.arrayMask(mask);
    // Subtract the indices to get run lengths.
    var groupSizes = runIndices.arraySlice(0, 1)
        .subtract(runIndices.arraySlice(0, 0, -1));
    return groupSizes;
  };
  
  // See equation 2.6 in Sen (1968).
  var factors = function(image) {
    return image.expression('b() * (b() - 1) * (b() * 2 + 5)');
  };
  
  var groupSizes = group(groups.toArray());
  var groupFactors = factors(groupSizes);
  var groupFactorSum = groupFactors.arrayReduce('sum', [0])
        .arrayGet([0, 0]);
  
  var count = joined.count();
  
  var kendallVariance = factors(count)
      .subtract(groupFactorSum)
      .divide(18)
      .float();
  // Map.addLayer(kendallVariance, {min: 1700, max: 85000}, 'kendallVariance');
  
  
  // Next, significance testing for the Mann-Kendall trend
  // Compute Z-statistics.
  var zero = kendall.multiply(kendall.eq(0));
  var pos = kendall.multiply(kendall.gt(0)).subtract(1);
  var neg = kendall.multiply(kendall.lt(0)).add(1);
  
  var z = zero
      .add(pos.divide(kendallVariance.sqrt()))
      .add(neg.divide(kendallVariance.sqrt()));
  // Map.addLayer(z, {min: -2, max: 2}, 'z');
  
  
  // Finally, compute P-values.
  // Uses cumulative distribution function ... defined above, before block
  var p = ee.Image(1).subtract(eeCdf(z.abs()));
  // Map.addLayer(p, {min: 0, max: 1}, 'p');
  
  // Pixels that can have the null hypothesis (there is no trend) rejected.
  // Specifically, if the true trend is zero, there would be less than 5%
  // chance of randomly obtaining the observed result (that there is a trend).
  var significant = p.lte(0.025);
  Map.addLayer(p.lte(0.025), {min: 0, max: 1}, 'significant trends');
  
  
  // Make imags for significant positive and significant negative trends
  var sigPos = significant.multiply(kendall.gt(0));
  var sigNeg = significant.multiply(kendall.lt(0));
  
  
  
  
  
  
  // EXPORTS
  
  // kendall
  var kendallForExport = kendall.double();
  Export.image.toDrive({
    image: kendallForExport,
    description: nameKendallGeoTIFF,
    folder: siteFolder,
    region: study_area,
    scale: siteScale,
    crs: siteCRS,
    fileFormat: 'GeoTIFF'
    });
  
  // Kendall pvalues
  Export.image.toDrive({
    image: p,
    description: namePvalGeoTIFF,
    folder: siteFolder,
    region: study_area,
    scale: siteScale,
    crs: siteCRS,
    fileFormat: 'GeoTIFF'
    });
  
  // Kendall significant pixels
  Export.image.toDrive({
    image: significant,
    description: nameSignificantGeoTIFF,
    folder: siteFolder,
    region: study_area,
    scale: siteScale,
    crs: siteCRS,
    fileFormat: 'GeoTIFF'
    });
  
  // NDVI change image
  Export.image.toDrive({
    image: changeNDVI,
    description: nameChangeGeoTIFF,
    folder: siteFolder,
    region: study_area,
    scale: siteScale,
    crs: siteCRS,
    fileFormat: 'GeoTIFF'
    });
    
  // all bands
  Export.image.toDrive({
    image: overallMeanImage,
    description: nameMeanGeoTIFF,
    folder: siteFolder,
    region: study_area,
    scale: siteScale,
    crs: siteCRS,
    fileFormat: 'GeoTIFF'
    });
    
  // Early NDVI
  Export.image.toDrive({
    image: earlyMean,
    description: nameEarlyGeoTIFF,
    folder: siteFolder,
    region: study_area,
    scale: siteScale,
    crs: siteCRS,
    fileFormat: 'GeoTIFF'
    });
    
  // Late NDVI
  Export.image.toDrive({
    image: lateMean,
    description: nameLateGeoTIFF,
    folder: siteFolder,
    region: study_area,
    scale: siteScale,
    crs: siteCRS,
    fileFormat: 'GeoTIFF'
    });
    
  // Mean NDVI
  Export.image.toDrive({
    image: overallMeanImage.select('NDVI'),
    description: nameNdviGeoTIFF,
    folder: siteFolder,
    region: study_area, 
    scale: siteScale,
    crs: siteCRS,
    fileFormat: 'GeoTIFF'
    });
    
  // Positive significant trend pixels
  Export.image.toDrive({
    image: sigPos,
    description: namePositiveGeoTIFF,
    folder: siteFolder,
    region: study_area,
    scale: siteScale,
    crs: siteCRS,
    fileFormat: 'GeoTIFF'
    });
    
  // Negative significant trend pixels
  Export.image.toDrive({
    image: sigNeg,
    description: nameNegativeGeoTIFF,
    folder: siteFolder,
    region: study_area,
    scale: siteScale,
    crs: siteCRS,
    fileFormat: 'GeoTIFF'
    });
    
  // Count of valid image dates per pixel
  Export.image.toDrive({
    image: validCountInt,
    description: nameValidCountGeoTIFF,
    folder: siteFolder,
    region: study_area,
    scale: siteScale,  
    crs: siteCRS,
    fileFormat: 'GeoTIFF'
    });
    
    
  // Make and export layers with the count of snowy pixels
  // This requires going back to the raw imagery and redoing the masks....
  // Note: to get the actual % of snowy pixels:  
  //      snow% = snowcount / (snowcount + pixelcount)
    
  // Mask images to keep only snow
  // Note this uses the adjusted NDSI; assumes values > 0 are snow
  var doMask_KeepSnow = function(myImage) {
    var NDSI2 = myImage.select('NDSI2');
    var snowMask = NDSI2.gte(0.0);
    var imgMasked = myImage.updateMask(snowMask);
    return imgMasked;
  };
  
  //Add a new band for SnowCount
  var addSnowCount = function(myImage) {
    var n = myImage.select('NDSI2');
    var pc = n.gt(-99);
    return myImage
    .addBands(pc.rename('SnowCount'));
  };
  
  // Re-collect images but only for snow cover during the summer season
  var snowImages5 = renamed5.map(addNDSI).map(addNDSI2_L5)
    .map(doMask_Cloud).map(doMask_Water).map(doMask_KeepSnow)
    .map(addSnowCount);
  var snowImages7 = renamed7.map(addNDSI).map(addNDSI2_L7)
    .map(doMask_Cloud).map(doMask_Water).map(doMask_KeepSnow)
    .map(addSnowCount);
  var snowImages8 = renamed8.map(addNDSI).map(addNDSI2_L8)
    .map(doMask_Cloud).map(doMask_Water).map(doMask_KeepSnow)
    .map(addSnowCount);
  var snowImages9 = renamed9.map(addNDSI).map(addNDSI2_L9)
    .map(doMask_Cloud).map(doMask_Water).map(doMask_KeepSnow)
    .map(addSnowCount);
  
  // Merge the images from all satellites
  var snowImages = snowImages5.merge(snowImages7).merge(snowImages8).merge(snowImages9);
  
  // Calculate the # of snowy image dates per pixel
  var getSnowCount = snowImages.select("SnowCount");
  var snowCount = getSnowCount.reduce(ee.Reducer.sum());
  var snowCountInt = snowCount.toInt();

  // Count of snowy image dates per pixel
  Export.image.toDrive({
    image: snowCountInt,
    description: nameSnowCountGeoTIFF,
    folder: siteFolder,
    region: study_area,  
    scale: siteScale,  
    crs: siteCRS,
    fileFormat: 'GeoTIFF'
    });
    
    
    
  // Make and export layers with the count of cloudy pixels
  // This requires going back to the raw imagery and redoing the masks....
  // Note: to get the actual % of cloudy pixels:  
  //      cloud% = cloudcount / (cloudcount + snowcount + pixelcount)
  

  // Mask images to keep only clouds
  var doMask_KeepCloud = function(myImage) {
    // Bit 0 = Fill
    // Bit 1 = Dilated Cloud
    // Bit 2 = Cirrus (Landsat-8 only)
    // Bit 3 = Cloud
    // Bit 4 = Cloud Shadow
    var qaMask = myImage
      .clip(study_area).select('QA_PIXEL')
      .bitwiseAnd(1).neq(0);
    var saturationMask = myImage
      .clip(study_area).select('QA_RADSAT').neq(0);
    var badPix = qaMask.or(saturationMask);
    var badPixBuffer = badPix.focal_max({
      radius: 60,
      kernelType: 'circle',
      units:'meters',
      iterations: 1
    });
    var keepCloudMask = myImage
      .clip(study_area).select('QA_PIXEL')
      .bitwiseAnd(parseInt('11110', 2)).neq(0);
    var comboMask = badPixBuffer.eq(0).and(keepCloudMask);
    var imgMasked = myImage.updateMask(comboMask);
    return imgMasked;
  };
  
  //Add a new band for CloudCount
  var addCloudCount = function(myImage) {
    var n = myImage.select('B');
    var pc = n.gt(-999);
    return myImage
    .addBands(pc.rename('CloudCount'));
  };

  // Re-collect images but only for cloud during the summer season
  var cloudImages5 = renamed5.map(doMask_KeepCloud).map(addCloudCount);
  var cloudImages7 = renamed7.map(doMask_KeepCloud).map(addCloudCount);
  var cloudImages8 = renamed8.map(doMask_KeepCloud).map(addCloudCount);
  var cloudImages9 = renamed9.map(doMask_KeepCloud).map(addCloudCount);
  
  // Merge the images from all satellites
  var cloudImages = cloudImages5.merge(cloudImages7).merge(cloudImages8).merge(cloudImages9);
  
  // Calculate the # of cloudy image dates per pixel
  var getCloudCount = cloudImages.select("CloudCount");
  var cloudCount = getCloudCount.reduce(ee.Reducer.sum());
  var cloudCountInt = cloudCount.toInt();

  // Count of cloudy image dates per pixel
  Export.image.toDrive({
    image: cloudCountInt,
    description: nameCloudCountGeoTIFF,
    folder: siteFolder,
    region: study_area,  
    scale: siteScale,  
    crs: siteCRS,
    fileFormat: 'GeoTIFF'
    });

} // End of exporting raster files (if make_raster_files == true)